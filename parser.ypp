%{
	#include "hw3_output.hpp"
	#include "Structs.hpp"
	#include "SymbolTables.hpp"
	#include "parser_funcs.hpp"
    #include <stdlib.h>
	using namespace output;

    typedef enum {
        ENUM_NONE,
        ENUM_ASSIGN,
        ENUM_RELOP,
        ENUM_AND,
        ENUM_OR,
        ENUM_NOT,
        ENUM_BINOP,
    } Operation;

    CodeBuffer& buffer = CodeBuffer::instance();

	int main();
    extern int yylineno;
    extern char* yytext;
    extern int yylex();
    void CheckLegalB(int n);
    Exp* NewCastedExp(const Exp* exp, const string& type);
    Function* GetFunction(string name, ArgVector& args);
    void AssertFunctionUseLegal(ArgVector& expected, ArgVector& current, string name);
    string GetAnnotation(string name);
    Exp* ExecuteOperation(Exp* exp1, Exp* exp2, Operation operation, const string& command, CodeBuffer* buffer);
    string GetType(string name);
    void AssertAssignLegal(string type1, string type2);
    bool NumberType(Exp* exp);
    void AssertLegalEpsilonFuncsDerivation();
    int yyerror(const char* message);
    void ValidateType(const string& x, const string& y);
    void exp_to_bool(Exp *bool_exp, CodeBuffer& buffer);
    void call_to_ir(Exp* call, Id* id, ExpList* expList, Function* f, bool is_with_args, CodeBuffer& buffer);
    void declarePrerequisites(CodeBuffer& buffer);

	class Parser {
	private:

		int loopCount = 0;
	public:
		TablesList symbolTable;
		Parser() {TablesList* p = new TablesList(); symbolTable = *p;};
		string ScopeReturnType = "";
		string ExpType;
		void AssertReturn(const string& retType){
			if (retType != ScopeReturnType && !(ScopeReturnType == "INT" && retType == "BYTE"))
			{
				output::errorMismatch(yylineno);
				exit(0);
			}
		}

		void EnterLoopScope(){
			loopCount++;
			symbolTable.OpenScope();

		}

		void ExitLoopScope(){
			loopCount--;
			symbolTable.CloseScope();
		}

		void AssertContinueLegal(){
			if (loopCount <= 0){
				output::errorUnexpectedContinue(yylineno);
				exit(1);
			}
		}

		void AssertBreakLegal(){
			if (loopCount <= 0){
				output::errorUnexpectedBreak(yylineno);
				exit(1);
			}
		}

	};

	class Generator {

    public:
        static size_t var_num = 0;
        static size_t str_num = 0;

        static string new_tmp() {
            string var = "%t" + to_string(var_num);
            var_num++;
            return var;
        }
        static string new_string() {
            string str = "@s" + to_string(str_num);
            str_num++;
            return str;
        }
    };

	extern Parser parser;
    string frame_pointer;
    int args_amount;
    bool return_happened = false;
    int curr_switch_num;

%}

%token VOID
%token INT
%token BYTE
%token B
%token BOOL
%token CONST
%token TRUE
%token FALSE
%token RETURN

%nonassoc IF
%nonassoc ELSE

%left RELOP_EQ RELOP_NOT_EQ

%nonassoc RELOP_LT RELOP_GT RELOP_LTE RELOP_GTE

%token WHILE
%token BREAK
%token CONTINUE
%token SC
%token COMMA
%token LBRACE
%token RBRACE
%token ID
%token NUM
%token STRING
%type<exp> NUM
%type<id> ID
%type<exp> Exp
%type<exp> Type
%type<exp> RetType
%type<exp> Call
%type<exp> TypeAnnotation
%type<argument> FormalDecl
%type<argument_list> FormalsList
%type<argument_list> Formals
%type<argument_list> ExpList


%right ASSIGN
%left OR
%left AND
%left RELOP_EQUAL
%nonassoc RELOP
%left BINOP_ADD
%left BINOP_SUB
%left BINOP_MULTIPLY
%left BINOP_DIV
%right NOT
%nonassoc RPAREN
%nonassoc LPAREN


%type<label> MarkInIF;
%type<label> M;
%type<block> N;
%type<block> Statement;
%type<block> Statements;
%type<scope> IfScope;
%type<scope> ElseScope;




%%
Program        : { declarePrerequisites(buffer); } Funcs                      {
																				  parser.symbolTable.CloseGlobal();
                                                                              }


Funcs          : FuncDecl Funcs                                               {
																				  /* No Action */
                                                                              }
               |                                                              {
                                                                                  AssertLegalEpsilonFuncsDerivation();
                                                                              }


FuncDecl       : RetType ID LPAREN Formals RPAREN                             {
																				   return_happened = false; parser.symbolTable.AddSymbol($2->name, $1->type, $4->arguments);
                                                                              }
                 LBRACE                                                       {
                                                                                  parser.symbolTable.OpenScope();
                                                                                  parser.ScopeReturnType = $1->type;
                                                                                  parser.symbolTable.AddArgsSymbols($4->arguments);

                                                                                  string ir_ret_type = curr_func_ret_type == "VOID" ? "void" : "i32";
                                                                                  Function* func_sym = dynamic_cast<Function*>(symbolTable.GetSymbol($2->name, true));

                                                                                  buffer.emit("define " + ir_ret_type + " @" + $2->name + func_sym->ir_params() + " {");
                                                                                  frame_pointer = Generator::new_tmp();
                                                                                  args_amount = $4->arguments.size();
                                                                                  buffer.emit(frame_pointer + " = alloca [" + to_string(50 + args_amount) + " x i32]");
                                                                                  for (int i = 0; i < args_amount; i++) {
                                                                                      string index = to_string(args_amount - i - 1);
                                                                                      string reg = "%" + to_string(i);
                                                                                      string ptr = Generator::new_tmp();
                                                                                      buffer.emit(ptr + " = getelementptr [" + to_string(50 + args_amount) + " x i32], [" + to_string(50 + args_amount) + " x i32]* " + frame_pointer + ", i32 0, i32 " + index);
                                                                                      buffer.emit("store i32 " + reg + ", i32* " + ptr);
                                                                                  }
                                                                              }
                 Statements RBRACE                                                
																			  {
                                                                                  parser.ScopeReturnType = "";
                                                                                  parser.symbolTable.CloseScope();
                                                                                  if(1) {
                                                                                      if(curr_func_ret_type == "VOID") {
                                                                                          buffer.emit("ret void");
                                                                                      }
                                                                                      else {
                                                                                          string ret_val = Generator::new_tmp();
                                                                                          buffer.emit(ret_val + " = add i32 0, 0");
                                                                                          buffer.emit("ret i32 " + ret_val);
                                                                                      }
                                                                                  }
                                                                                  buffer.emit("}");
                                                                                  curr_func_ret_type = "";
                                                                              }

RetType        : Type                                                         {
                                                                                  $$ = new Exp($1->type);
                                                                              }
               | VOID                                                         {
                                                                                  $$ = new Exp("VOID");
                                                                              }														  


Formals        : FormalsList                                                  {
                                                                                  $$->arguments = $1->arguments;
                                                                              }
               |                                                              {
                                                                                  $$ = new ArgumentList();
                                                                              }


FormalsList    : FormalDecl                                                   {
                                                                                  $$ = new ArgumentList();
                                                                                  $$->arguments.push_back(*$1);
                                                                              }
               | FormalDecl COMMA FormalsList                                 {
                                                                                  $$ = new ArgumentList();
                                                                                  $$->arguments = $3->arguments;
                                                                                  $$->arguments.push_back(*$1);
                                                                              }


FormalDecl     : TypeAnnotation Type ID                                       {
                                                                                  $$ = new Argument($1->type, $3->name, $2->type);
                                                                              }
IfScope        : IF LPAREN Exp RPAREN MarkInIF OpenScope Statement CloseScope {
                                                                                  $$ = new Scope($3, $5->label, $7->nextList, $7->breakList, $7->continueList);
                                                                              }

ElseScope      :   ELSE N M OpenScope Statement CloseScope                    {
                                                                                  $$ = new Scope(nullptr, $3->label, buffer.merge($2->nextList, $5->nextList), buffer.merge($2->breakList, $5->breakList), buffer.merge($2->continueList, $5->continueList));
                                                                              }

M           :   /* No Action */                                               { $$ = new Label(buffer.genLabel()); }

N           :   /* No Action */                                               {
                                                                              int address = buffer.emit("br label @");
                                                                              $$ = new Block();
                                                                              $$->nextList = CodeBuffer::makelist({address, FIRST});
                                                                            }

Statements     : Statement                                                    {
                                                                                  $$ = new Block();
                                                                                  $$->nextList = $1->nextList;
                                                                                  $$->breakList = $1->breakList;
                                                                                  $$->continueList = $1->continueList;
                                                                              }
               | Statements Statement                                         {
                                                                                  $$ = new Block();
                                                                                  $$->nextList = CodeBuffer::merge($1->nextList, $2->nextList);
                                                                                  $$->breakList = CodeBuffer::merge($1->breakList, $2->breakList);
                                                                                  $$->continueList = CodeBuffer::merge($1->continueList, $2->continueList);
                                                                              }
Statement      : LBRACE ScopeStart Statements RBRACE ScopeEnd                 {
                                                                                  $$ = new Block();
                                                                                  $$->nextList = $3->nextList;
                                                                                  $$->breakList = $3->breakList;
                                                                                  $$->continueList = $3->continueList;
                                                                              }
               | TypeAnnotation Type ID SC                                    {
																				 if($1->type == "CONST") {
																					output::errorConstDef(yylineno);
																					exit(1);
																				 }
																				 parser.symbolTable.AddSymbol($1->type, $3->name, $2->type);
																				 string offset = to_string(parser.symbolTable.GetSymbol($2->name, false)->offset + args_amount);
                                                                                 string ptr = Generator::new_tmp();

                                                                                 buffer.emit(ptr + " = getelementptr [" + to_string(50 + args_amount) + " x i32], [" + to_string(50 + args_amount) + " x i32]* " + frame_pointer + ", i32 0, i32 " + offset);
                                                                                 buffer.emit("store i32 0, i32* " + ptr);
                                                                                 $$ = new Block();
                                                                              }
               | TypeAnnotation Type ID ASSIGN Exp SC                         {
																				 AssertAssignLegal($2->type, $5->type);
                                                                                 parser.symbolTable.AddSymbol($1->type, $3->name, $2->type);
                                                                                 if ($1->type == "BOOL") {
                                                                                    exp_to_bool($4, buffer);
                                                                                 }

                                                                                 string offset = to_string(parser.symbolTable.GetSymbol($2->name, false)->offset + args_amount);
                                                                                 string ptr = Generator::new_tmp();

                                                                                 buffer.emit(ptr + " = getelementptr [" + to_string(50 + args_amount) + " x i32], [" + to_string(50 + args_amount) + " x i32]* " + frame_pointer + ", i32 0, i32 " + offset);
                                                                                 buffer.emit("store i32 " + $4->reg + ", i32* " + ptr);
                                                                                 $$ = new Block();
                                                                              }
               | ID ASSIGN Exp SC                                             {
																				  if(GetAnnotation($1->name) == "CONST") {
																					output::errorConstMismatch(yylineno);
																					exit(1);
																				  }
																				  AssertAssignLegal(GetType($1->name), $3->type);
																				  if (type == "BOOL") {
                                                                                    exp_to_bool($3, buffer);
                                                                                  }
                                                                                  string offset = to_string(parser.symbolTable.GetSymbol($1->name, false)->offset + args_amount);
                                                                                  string ptr = Generator::new_tmp();

                                                                                  buffer.emit(ptr + " = getelementptr [" + to_string(50 + args_amount) + " x i32], [" + to_string(50 + args_amount) + " x i32]* " + frame_pointer + ", i32 0, i32 " + offset);
                                                                                  buffer.emit("store i32 " + $3->reg + ", i32* " + ptr);
                                                                                  $$ = new Block();
                                                                              }
               | Call SC                                                      {
                                                                                  $$ = new Block();
                                                                                  if ($1->type == "BOOL") {
                                                                                      string nextLabel = buffer.genLabel();
                                                                                      buffer.bpatch($1->trueList, nextLabel);
                                                                                      buffer.bpatch($1->falseList, nextLabel);
                                                                                  }
                                                                              }
               | RETURN SC                                                    {
                                                                                  parser.AssertReturn("VOID");//TODO do we need this and validate type too? or just one of them
                                                                                  return_happened = true;

                                                                                  buffer.emit("ret void");
                                                                                  $$ = new Block();
                                                                              }
               | RETURN Exp SC                                                {
                                                                                  return_happened = true;
																				  if(parser.ScopeReturnType == "VOID") {
																					output::errorMismatch(yylineno);
																					exit(1);
																				  }
																				  parser.AssertReturn($2->type);
																				  AssertAssignLegal(curr_func_ret_type, $2->type);//TODO do we need this?
																				  if (curr_func_ret_type == "BOOL") {
                                                                                      exp_to_bool($2, buffer);
                                                                                  }

                                                                                  buffer.emit("ret i32 " + $2->reg);
                                                                                  $$ = new Block();
                                                                              }
               | IfScope %prec IF
                                                                              {
                                                                                  buffer.bpatch($1->exp->trueList, $1->label);
                                                                                  $$ = new Block();
                                                                                  $$->breakList = $1->block->breakList;
                                                                                  $$->continueList = $1->block->continueList;
                                                                                  $$->nextList = CodeBuffer::merge($1->exp->falseList, $1->block->nextList);
                                                                                  int address = buffer.emit("br label @");
                                                                                  $$->nextList = CodeBuffer::merge($$->nextList, CodeBuffer::makelist({address, FIRST}));
                                                                                  string label = buffer.genLabel();
                                                                                  buffer.bpatch($$->nextList, label);
                                                                              }
               | IfScope ElseScope
                                                                              {
                                                                                buffer.bpatch($1->exp->falseList, $2->label);
                                                                                buffer.bpatch($1->exp->trueList, $1->label);

                                                                                $$ = new Block();
                                                                                $$->breakList = CodeBuffer::merge($1->block->breakList, $2->block->breakList);
                                                                                $$->continueList = CodeBuffer::merge($1->block->continueList, $2->block->continueList);
                                                                                $$->nextList = CodeBuffer::merge($1->block->nextList, $2->block->nextList);
                                                                                // $$->nextList = CodeBuffer::merge($$->nextList, $9->nextList);

                                                                                int address = buffer.emit("br label @");
                                                                                $$->nextList = CodeBuffer::merge($$->nextList, CodeBuffer::makelist({address, FIRST}));
                                                                                string label = buffer.genLabel();
                                                                                buffer.bpatch($$->nextList, label);
                                                                              }

               | WHILE LPAREN N M Exp RPAREN
                                                                              {
                                                                                vaildate_type($5->type, "BOOL");
                                                                                    during_while++;
                                                                                    symbolTable.open_scope();
                                                                                }
                 M Statement
                                                                              {
                                                                                  parser.ExitLoopScope();

                                                                                  symbolTable.close_scope();//TODO dont this we need this
                                                                                  during_while--;
                                                                                  $$ = new Block();
                                                                                  buffer.bpatch($9->continueList, $4->label);
                                                                                  buffer.bpatch($5->trueList, $8->label);
                                                                                  buffer.bpatch($9->nextList, $4->label);
                                                                                  buffer.bpatch($3->nextList, $4->label);
                                                                                  $$->nextList = CodeBuffer::merge($5->falseList, $9->breakList);
                                                                                  buffer.emit("br label %" + $4->label);
                                                                                  string label = buffer.genLabel();
                                                                                  // buffer.bpatch($$->nextList, label);
                                                                                  buffer.bpatch($9->breakList, label);
                                                                                  buffer.bpatch($5->falseList, label);
                                                                              }
               | IF LPAREN Exp CheckBool RPAREN ScopeStart Statement ScopeEnd
                                                                              {
                                                                                 /* No Action */
                                                                              }
               | IF LPAREN Exp CheckBool RPAREN ScopeStart Statement ScopeEnd ELSE ScopeStart Statement ScopeEnd
                                                                              {
                                                                                 /* No Action */
                                                                              }
               | WHILE LPAREN Exp CheckBool RPAREN                             
																			  {
                                                                                  parser.EnterLoopScope();
                                                                              }
               | BREAK SC                                                     {
                                                                                  parser.AssertBreakLegal();

                                                                                      $$ = new Block();
                                                                                      int address = buffer.emit("br label @");
                                                                                      $$->breakList = CodeBuffer::makelist({address, FIRST});
                                                                                  }
               | CONTINUE SC                                                  {
                                                                                  parser.AssertContinueLegal();
                                                                                  $$ = new Block();
                                                                                  int address = buffer.emit("br label @");
                                                                                  $$->continueList = CodeBuffer::makelist({address, FIRST});
                                                                              }

MarkInIf       : /* No Action */
                                                                              {
                                                                                  vaildate_type(curr_exp_type, "BOOL");
                                                                                  $$ = new Label(buffer.genLabel());
                                                                              }

Call           : ID LPAREN ExpList RPAREN                                     {
                                                                                  $$ = new Exp(GetFunction($1->name, $3->arguments)->return_type);
                                                                                  if ($1->name == "print") {
                                                                                      auto strExp = $3->exp.at(0);
                                                                                      buffer.emit("call void @print(i8* getelementptr ([" + strExp->size + " x i8], [" + strExp->size + " x i8]* " + strExp->reg + ", i32 0, i32 0))");
                                                                                  } else {
                                                                                      call_to_ir($$, $1, $3, f, true, buffer);
                                                                                  }
                                                                              }
               | ID LPAREN RPAREN                                             {
																				  ArgumentList *arg_list = new ArgumentList();
                                                                                  $$ = new Exp(GetFunction($1->name, arg_list->arguments)->return_type);
                                                                                  call_to_ir($$, $1, nullptr, f, false, buffer);
                                                                              }


ExpList        : Exp                                                          {
                                                                                  $$ = new ArgumentList();
                                                                                  $$->arguments.push_back(Argument($1->type, $1->name, $1->type));
                                                                                  $$->exp.push_back($1);
                                                                                  if ($1->type == "BOOL") {
                                                                                      exp_to_bool($1, buffer);
                                                                                  }
                                                                              }
               | Exp COMMA                                                    {
                                                                                  if ($1->type == "BOOL") {
                                                                                      exp_to_bool($1, buffer);
                                                                                  }
                                                                              }
               ExpList                                                        {
                                                                                  $$ = new ArgumentList();
                                                                                  $$ = $3;
                                                                                  $$->arguments.push_back(Argument($1->type, $1->name, $1->type));
                                                                              }

Type           : INT                                                          {
																			   $$ = new Exp("INT");
                                                                              }
               | BYTE                                                         {
                                                                               $$ = new Exp("BYTE");
                                                                              }
               | BOOL                                                         {
                                                                               $$ = new Exp("BOOL");
                                                                              }


TypeAnnotation : CONST                                                        {//TODO check if need to add something
																				  $$ = new Exp("CONST");
                                                                              }
               |                                                              {
                                                                                  $$ = new Exp("");
                                                                              }


Exp            : LPAREN Exp RPAREN                                            {
                                                                                  $$ = new Exp($2->type);
                                                                                  parser.ExpType = "INT";

                                                                                  $$->reg = $2->reg;
                                                                                  $$->trueList = $2->trueList;
                                                                                  $$->falseList = $2->falseList;
                                                                              }
               | Exp BINOP_ADD Exp                                            {
                                                                                  $$ = ExecuteOperation($1, $3, ENUM_BINOP, "add");
                                                                                  parser.ExpType = "INT";
                                                                              }
               | Exp BINOP_SUB Exp                                            {
                                                                                  $$ = ExecuteOperation($1, $3, ENUM_SUB, "sub");
                                                                                  parser.ExpType = "INT";
                                                                              }
               | Exp BINOP_MULTIPLY Exp                                       {
                                                                                  $$ = ExecuteOperation($1, $3, ENUM_BINOP, "mul");
                                                                                  parser.ExpType = "INT";
                                                                              }
               | Exp BINOP_MULTIPLY Exp                                       {
                                                                                  $$ = ExecuteOperation($1, $3, ENUM_BINOP, "div");
                                                                                  parser.ExpType = "INT";
                                                                              }
               | ID                                                           {
																				  $$ = new Exp(GetType($1->name));
                                                                                  $$->name = $1->name;
                                                                                  parser.ExpType = GetType($1->name);

                                                                                  {
                                                                                      auto sym = parser.symbolTable.search_symbol($1->name, false);
                                                                                      string type = GetType($1->name);
                                                                                      $$ = new Exp(type);
                                                                                      $$->name = $1->name;
                                                                                      curr_exp_type = type;

                                                                                      string ptr = Generator::new_tmp();
                                                                                      $$->reg = Generator::new_tmp();
                                                                                      string offset = to_string(sym->offset + args_amount);
                                                                                      buffer.emit(ptr + " = getelementptr [" + to_string(50 + args_amount) + " x i32], [" + to_string(50 + args_amount) + " x i32]* " + frame_pointer + ", i32 0, i32 " + offset);
                                                                                      buffer.emit($$->reg + " = load i32, i32* " + ptr);

                                                                                      if (sym->type == "BOOL") {
                                                                                          string cond = Generator::new_tmp();
                                                                                          buffer.emit(cond + " = icmp eq i32 " + $$->reg + ", 1");
                                                                                          int address = buffer.emit("br i1 " + cond + ", label @, label @");
                                                                                          $$->trueList = CodeBuffer::merge($$->trueList, CodeBuffer::makelist({address, FIRST}));
                                                                                          $$->falseList = CodeBuffer::merge($$->falseList, CodeBuffer::makelist({address, SECOND}));
                                                                                      }
                                                                                  }

                                                                              }
               | Call                                                         {
                                                                                  $$ = new Exp($1->type);
                                                                                  parser.ExpType = $1->type;

                                                                                  if ($$->type != "VOID") {
                                                                                      $$->reg = $1->reg;
                                                                                  }
                                                                                  $$->trueList = $1->trueList;
                                                                                  $$->falseList = $1->falseList;
                                                                              }
               | NUM                                                          {
																				  $$ = new Exp("INT");
                                                                                  parser.ExpType = "INT";

                                                                                  $$->reg = Generator::new_tmp();
                                                                                  buffer.emit($$->reg + " = add i32 0, " + to_string(yylval.val));
                                                                              }
               | NUM B                                                        {
                                                                                CheckLegalB(yylval.val);
                                                                                  $$ = new Exp("BYTE");
                                                                                  parser.ExpType = "BYTE";

                                                                                  $$->reg = Generator::new_tmp();
                                                                                  buffer.emit($$->reg + " = add i32 0, " + to_string(yylval.val));
                                                                              }
               | STRING                                                       {
                                                                                  $$ = new Exp("STRING");
                                                                                  parser.ExpType = "STRING";

                                                                                  $$->reg = Generator::new_string();
                                                                                  $$->size = to_string(yylval.id->name.size() + 1);
                                                                                  buffer.emitGlobal($$->reg + " = global [" + $$->size + " x i8] c\"" + yylval.id->name + "\\00\"");
                                                                              }
               | TRUE                                                         {
                                                                                  $$ = new Exp("BOOL");
                                                                                  parser.ExpType = "BOOL";

                                                                                  int address = buffer.emit("br label @");
                                                                                  $$->trueList = CodeBuffer::merge($$->trueList, CodeBuffer::makelist({address, FIRST}));
                                                                              }
               | FALSE                                                        {
                                                                                  $$ = new Exp("BOOL");
                                                                                  parser.ExpType = "BOOL";

                                                                                  int address = buffer.emit("br label @");
                                                                                  $$->falseList = CodeBuffer::merge($$->falseList, CodeBuffer::makelist({address, FIRST}));
                                                                              }
               | NOT Exp                                                      {
                                                                                  $$ = ExecuteOperation($2, $2, ENUM_NOT);
                                                                                  parser.ExpType = "BOOL";
                                                                              }
               | Exp AND M Exp                                                {
                                                                                  buffer.bpatch($1->trueList, $3->label);
                                                                                  $$ = ExecuteOperation($1, $3, ENUM_AND);
                                                                                  parser.ExpType = "BOOL";
                                                                              }
               | Exp OR M Exp                                                 {
                                                                                  buffer.bpatch($1->falseList, $3->label);
                                                                                  $$ = ExecuteOperation($1, $3, ENUM_OR);
                                                                                  parser.ExpType = "BOOL";
                                                                              }
               | Exp RELOP_EQUAL Exp                                          {
                                                                                  $$ = ExecuteOperation($1, $3, ENUM_RELOP, "eq");
                                                                                  parser.ExpType = "BOOL";
                                                                              }
               | Exp RELOP_NOT_EQUAL Exp                                          {
                                                                                  $$ = ExecuteOperation($1, $3, ENUM_RELOP, "ne");
                                                                                  parser.ExpType = "BOOL";
                                                                              }
               | Exp RELOP_LT Exp                                          {
                                                                                  $$ = ExecuteOperation($1, $3, ENUM_RELOP, "slt");
                                                                                  parser.ExpType = "BOOL";
                                                                              }
               | Exp RELOP_GT Exp                                          {
                                                                                  $$ = ExecuteOperation($1, $3, ENUM_RELOP, "sgt");
                                                                                  parser.ExpType = "BOOL";
                                                                              }
               | Exp RELOP_LTE Exp                                          {
                                                                                  $$ = ExecuteOperation($1, $3, ENUM_RELOP, "sle");
                                                                                  parser.ExpType = "BOOL";
                                                                              }
               | Exp RELOP_GTE Exp                                                {
                                                                                  $$ = ExecuteOperation($1, $3, ENUM_RELOP, "sge");
                                                                                  parser.ExpType = "BOOL";
                                                                              }
               | LPAREN Type RPAREN Exp                                       {
                                                                                  $$ = NewCastedExp($4, $2->type);//TODO add things for hw5
                                                                              }
ScopeStart      :                                                             {
                                                                                  parser.symbolTable.OpenScope();
                                                                              }


ScopeEnd        :                                                             {
                                                                                  parser.symbolTable.CloseScope();
                                                                              }
																			  
CheckBool		:															  {
                                                                                  if (parser.ExpType !="BOOL")
                                                                                  {
                                                                                      errorMismatch(yylineno);
                                                                                      exit(1);
                                                                                  }
																			  }


%%

int main()
{
	yyparse();
	buffer.printGlobalBuffer();
    buffer.printCodeBuffer();
}

int yyerror(const char* message)
{
	errorSyn(yylineno);
	exit(1);
}

inline void CheckLegalB(int n)
{
    if (n > 255)
    {
        errorByteTooLarge(yylineno, to_string(yylval.val));
        exit(1);
    }
}

void AssertAssignLegal(string type1, string type2) {
    if((type1 != type2 && (type1 != "INT" || type2 != "BYTE")) || type1 == "VOID") {
        errorMismatch(yylineno);
        exit(1);
    }
}

void AssertLegalEpsilonFuncsDerivation(){
    if(string(yytext) != "") {
        yyerror(nullptr);
    }
}

void AssertFunctionUseLegal(ArgVector& expected, ArgVector& current, string name) {
    if (expected.size() != current.size())
    {
        errorPrototypeMismatch(yylineno, name, expected);
        exit(1);
    }
    int size = expected.size();
    for(int i=0; i < size; i++){
        if(expected[i].type != current[size-i-1].type && !(expected[i].type == "INT" && current[size-i-1].type == "BYTE")){
            errorPrototypeMismatch(yylineno, name, expected);
            exit(1);
        }
    }
}

inline bool NumberType(Exp* exp) {
    if (exp->type != "BYTE" && exp->type != "INT"){
        return false;
    }
    return true;
}

string GetType(string name) {
    Symbol* symbol = nullptr;
    symbol =  parser.symbolTable.GetSymbol(name, false);
    if(symbol == nullptr) {
        errorUndef(yylineno, name);
        exit(1);
    }
    return symbol->type;
}

string GetAnnotation(string name) {
    Variable* symbol;
    symbol = (Variable*)parser.symbolTable.GetSymbol(name, false);
    if (symbol == nullptr){
        errorUndef(yylineno, name);
        exit(1);
    }
    return symbol->type_annotation;
}

Exp* ExecuteOperation(Exp* exp1, Exp* exp2, Operation operation, const string& command, CodeBuffer* buffer) {
    if(exp1->type == "STRING" || exp2->type == "STRING") {
        errorMismatch(yylineno);
        exit(1);
    }

    switch(operation)
    {
         case(ENUM_NOT):
         {
              if (exp1->type == "BOOL") {
                  Exp* exp = new Exp("BOOL");
                  exp->falseList = var1->trueList;
                  exp->trueList = var1->falseList;
                  return exp;
              }
              break;
         }

         case(ENUM_RELOP):
         {
             if (NumberType(exp1) && NumberType(exp2)) {
                 return new Exp("BOOL");
                 string cond = Generator::new_tmp();
                     if (exp1->type == "BYTE" && exp2->type == "BYTE" && command != "eq" && command != "ne") // unsigned ops for lt,gt,le,ge
                         buffer.emit(cond + " = icmp " + "u" + command.substr(1) + " i32 " + exp1->reg + ", " + exp2->reg);
                     else
                         buffer.emit(cond + " = icmp " + command + " i32 " + exp1->reg + ", " + exp2->reg);

                     int address = buffer.emit("br i1 " + cond + ", label @, label @");
                     ret->trueList = CodeBuffer::merge(ret->trueList, CodeBuffer::makelist({address, FIRST}));
                     ret->falseList = CodeBuffer::merge(ret->falseList, CodeBuffer::makelist({address, SECOND}));
                     return ret;
                 }
             break;
         }

        case(ENUM_ASSIGN):
        {
            AssertAssignLegal(exp1->type, exp2->type);
            return exp1;
        }

        case(ENUM_AND):
        {
            if (exp1->type == "BOOL" && exp2->type == "BOOL") {
                Exp *exp = new Exp("BOOL");
                exp->falseList = CodeBuffer::merge(exp1->falseList, exp2->falseList);
                exp->trueList = CodeBuffer::merge(exp->trueList, exp2->trueList);
                return exp;
            }
            break;
        }
        case(ENUM_OR):
        {
           if (exp1->type == "BOOL" && exp2->type == "BOOL"){
               Exp *exp = new Exp("BOOL");
               exp->trueList = CodeBuffer::merge(exp1->trueList, exp2->trueList);
               exp->falseList = CodeBuffer::merge(exp->falseList, exp2->falseList);
               return exp;
           }
           break;
        }

        case(ENUM_BINOP):
        {
            if (NumberType(exp1) && NumberType(exp2)){
                string reg = Generator::new_tmp();
                if (command == "sdiv") // special handling
                    div_handler(exp1, exp2, reg, buffer);
                else
                    emit_op(reg, exp1->reg, exp2->reg, command, buffer);

                if(exp1->type == "INT" || exp2->type == "INT")
                    return new Exp("INT", reg);
                else{
                    string temp = reg;
                    reg = Generator::new_tmp();
                    buffer.emit(reg + " = and i32 " + temp + ", 255");
                    return new Exp("BYTE", reg);
                }
            }
            break;
        }
    }
    errorMismatch(yylineno);
    exit(1);
}

Function* GetFunction(string name, ArgVector& args){
    Function* function;
    function = (Function*)(parser.symbolTable.GetSymbol(name, true));
    if (function == nullptr) {
        errorUndefFunc(yylineno, name);
        exit(1);
    }

    AssertFunctionUseLegal(function->args, args, function->name);
    return function;
}

Exp* NewCastedExp(const Exp* exp, const string& type) {
    string eType = exp->type;
    if((type == "BYTE" || type == "INT") && (eType == "BYTE" || eType == "INT")){
        return new Exp(type);
    }
    errorMismatch(yylineno);
    exit(1);
}

void ValidateType(const string& x, const string& y) {
    if (x != y)
        {
            output::errorMismatch(yylineno);
            exit(0);
        }
}

void exp_to_bool(Exp *exp, CodeBuffer& buffer) {
    exp->reg = Generator::new_tmp();
    string true_label = buffer.genLabel();
    int true_address = buffer.emit("br label @");
    string false_label = buffer.genLabel();
    int false_address = buffer.emit("br label @");
    string end_label = buffer.genLabel();
    buffer.emit(exp->reg + " = phi i32 [1, %" + true_label + "], [0, %" + false_label + "]");
    buffer.bpatch(CodeBuffer::makelist({true_address, FIRST}), end_label);
    buffer.bpatch(CodeBuffer::makelist({false_address, FIRST}), end_label);
    // buffer.bpatch(CodeBuffer::makelist({shit_address, FIRST}), true_label);

    buffer.bpatch(exp->trueList, true_label);
    buffer.bpatch(exp->falseList, false_label);
}



void call_to_ir(Exp* call, Id* id, ExpList* expList, Function* f, bool is_with_args, CodeBuffer& buffer) {
    string ir_ret_type = f->return_type == "VOID" ? "void" : "i32";
    string call_string;
    if(f->return_type != "VOID") {
        call->reg = Generator::new_tmp();
        call_string += call->reg + " = ";
    }

    if(is_with_args) {
        call_string += "call " + ir_ret_type + " " + f->ir_params() + " @" + id->name + "(";
        if (!expList->exp.empty()) {
            call_string += "i32 " + expList->exp.back()->reg;
            for (auto i= ++expList->exp.rbegin(); i != expList->exp.rend(); i++) {
                call_string += ", i32 " + (*i)->reg;
            }
        }
        call_string += ")";
    } else {
        call_string += "call " + ir_ret_type + " " + f->ir_params() + " @" + id->name + "()";
    }
    buffer.emit(call_string);

    if (f->return_type == "BOOL") {
        string cond = Generator::new_tmp();
        buffer.emit(cond + " = icmp ne i32 0, " + call->reg);
        int address = buffer.emit("br i1 " + cond + ", label @, label @");
        call->trueList = CodeBuffer::merge(call->trueList, CodeBuffer::makelist({address, FIRST}));
        call->falseList = CodeBuffer::merge(call->falseList, CodeBuffer::makelist({address, SECOND}));
    }
}


void declarePrerequisites(CodeBuffer& buffer) {
    // Standard C function declarations
    buffer.emit("declare i32 @printf(i8*, ...)");
    buffer.emit("declare void @exit(i32)");
    buffer.emit("declare i8* @malloc(i32)");
    buffer.emit("declare void @free(i8*)");
    buffer.emit("declare void @llvm.memset.p0i8.i32(i8*, i8, i32, i1)");
    buffer.emit("declare void @llvm.memcpy.p0i8.p0i8.i32(i8*, i8*, i32, i1)");


    // Global declarations
    buffer.emitGlobal("@.int_specifier = constant [4 x i8] c\"%d\\0A\\00\"");
    buffer.emitGlobal("@.str_specifier = constant [4 x i8] c\"%s\\0A\\00\"");
    buffer.emitGlobal("@zero_div_error = constant [24 x i8] c\"Error division by zero\n\\00\"");

    // print declaration
    buffer.emit("define void @printi(i32) {");
    buffer.emit("call i32 (i8*, ...) @printf(i8* getelementptr ([4 x i8], [4 x i8]* @.int_specifier, i32 0, i32 0), i32 %0)");
    buffer.emit("ret void");
    buffer.emit("}");

    // printi declaration
    buffer.emit("define void @print(i8*) {");
    buffer.emit("call i32 (i8*, ...) @printf(i8* getelementptr ([4 x i8], [4 x i8]* @.str_specifier, i32 0, i32 0), i8* %0)");
    buffer.emit("ret void");
    buffer.emit("}");
}